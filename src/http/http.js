import { fetchBaseQuery } from "@reduxjs/toolkit/query";
import localStorageService from "../services/localStorage.service";
import { tokenReceived, loggedOut } from "./authSlice";

const baseQuery = fetchBaseQuery({
    baseUrl: "http://176.99.11.245/api/",
    prepareHeaders: (headers) => {
        const accessToken = localStorageService.getAccessToken();
        if (accessToken) {
            headers.set("authorization", `Bearer ${accessToken}`);
        }
        return headers;
    }
});
const baseQueryWithReauth = async (args, api, extraOptions) => {
    let result = await baseQuery(args, api, extraOptions);
    console.log(result);
    //отследить цепочку до статус кода
    if (result.error && result.error.status === 401) {
        const finalEndpoint =
            localStorageService.getIsStaff() === "true"
                ? "/AdminPanel/RefreshTokens"
                : "/Authenticate/RefreshToken";
        const { data } = await baseQuery(
            {
                url: finalEndpoint,
                body: {
                    token: localStorageService.getAccessToken(),
                    refreshToken: localStorageService.getRefreshToken()
                }
            },
            api,
            extraOptions
        );
        if (data) {
            const { refreshToken, accessToken } = data;
            // store the new token
            localStorageService.setTokens(refreshToken, accessToken);
            // retry the initial query
            result = await baseQuery(args, api, extraOptions);
        } else {
            //поменять диспатч
            api.dispatch(loggedOut());
        }
    }
    return result;
};

const Event = {
    id: "айди ивента",
    eventStart: "дата/время начала непосредственно ивента",
    registrationStart: "дата/время открытия регистрации на ивент",
    registrationEnd: "дата/время окончания регистрации на ивент",
    regime: "SOLO / DUO / SQUAD",
    view: "1st person / 3rd person",
    owner: "id организатора", // тот, кто непосредственно будет создавать ивент в частности
    staff: ["id модератора 1", "id модератора 2"], // айди всех модераторов, которые были зарегистрированы организатором на ивент
    type: "free / paid", // ивент может быть бесплатный для входа, за плату
    sponsored: "true/false хз чо пока",
    requirements: "текст условий, если есть, если нет - пусто", // есть дополнительные условия для участия или нет. Если нет - игроки/команды автоматичиски апрувятся до участия
    participants: {
        onreview: ["id команды или игрока 1", "id команды или игрока 2"], //массив айди игроков или команд, подавших заявку на регистрацию на ивенте
        approved: ["id команды или игрока 1", "id команды или игрока 2"] // массив игроков или команд, одобренных до участия на ивенте
    },
    maxQuantity: "для примера: 128", //максимальное количество участников ивента
    stages: {
        "id этапа": {
            stage
        }
    },
    winner: "id победителя",
    prize: {
        "общий фонд": "100000",
        "награда за килы": "число или пусто", // награды может не быть
        "награда за место": "число или пусто" // награды может не быть
    }
};

const stage = {
    id: "айди этапа",
    stageStart: "время начала этапа",
    groups: {
        "id группы": {
            group
        }
    },

    winners: ["id команды или игрока 1", "id команды или игрока 2"],
    reshuffleEnded: "за 3 часа(время)" // время до начала группы, когда можно сменить слот
};

const groups = {
    "id группы": {
        name: "Группа 1",
        groupStart: "время начала матча",
        topWinners: "число, для примера: 4", // топ участников по результатам групп/матчей, проходящих в следующий этап
        participants: {
            10: "id участника",
            11: "id участника",
            12: "id участника"
        },
        map: "Эрангель / Мирамар / Санук / Викенди / Ливик / Arcade Эрангель / TDM Склад",
        staff: ["id модератора 1", "id модератора 2"],
        results: {
            "id участника": {
                "id игрока": { kills: "число" },
                place: "число" //место команды или игрока в матче
            },
            "id участника": {
                "id игрока": { kills: "число" },
                place: "число" //место команды или игрока в матче
            }
        }
    }
};

// сценарий
// Регистрация на ивент
// В случае регистрации команды -> редирект на страничку с доступными для регистрации командами (тут подтягиваются данные юзера) -> запрос на участие(прокидывается id участника)
// в event.participants.onreview
// В случае соло игрока -> запрос на участие(прокидывается id участника) в event.participants.onreview
// websocket подписывается на отслеживание наличия id участиника в event.participants
// если id участника появилось в onreview -> отправить уведомление, что он подал заявку
// если id участника появилось в approved -> отправить уведомление, что он одобрен к участию
// если id участника появилось исчезло из event.participants -> отправить уведомление, что он не прошёл отбор

// Организатор турнира или его модераторы в своём личном кабинете видят поле текущего ивента, в котором будет отображаться список подавших заявки. Напротив каждой заявки будет кнопка
// "одобрить участие" или "отклонить" -> посылается запрос на сервер. В случае одобрения, id участника прокидывается в event.participants.approved, в случае отклонения
// из event.participants.onreview  удаляется айди подавшего заявку.

// чтобы пройти одобренным участникам на страницу выбора групп делаем протектед рут, в котором проверяем наличие айди участника в event.participants.approved (подтягиваются данные
// по ивенту и по конкретному юзеру, если режим ивента сквад - проверяться будет команда, если нет - айди юзера

// группа и соответственно слот выбирается юзером или любым юзером из команды, если свободных нет: выбирается резерв -> отправляется запрос на заполнение слота в группе, для примера:
// groups."id группы".participants."номер слота": "айди участника" ->уведомление по websocket о выборе группы

// через websocket отправляется подтверждение об участии, соответственно через него же приходит список участников групп в личном кабинете орга/модераторов, подтвердивших участие
// если участник не подтвердил вовремя -> он удаляется из "id группы".participants."номер слота": "айди участника" и через websocket отправляются уведомления о удалении участнику и оргу
// если есть резерв - из него в порядке очереди автоматически вставляется участник в "id группы".participants."номер слота": "айди участника" и отправляется уведомление
// об участии в игре как организаторам/модераторам, так и участнику.

// по окончанию игры орг/модер заполняет результаты по каждому участнику в groups."id группы".results."id участника", отправляются на сервер и по веб сокету отправляется уведомление
// о прохождении в следующий этап или победе. В том числе прокидываются id победителей группы, проходящих по условию "топ списка" в следующий этап
// *как понять, что последний этап - последнийй, ещё надо подумать*

// организатор отправляет запрос на сервер о выплате победителю приза, уведомления по websocket, если команда - выплата поровну

export default baseQueryWithReauth;
